# 弹性设计

```
原标题：Resilience
原文地址：https://github.com/apple/swift/blob/master/docs/archive/Resilience.rst
```
## 警告
这是一篇非常早的讨论弹性这一特性的设计文档。不应将当前文档视作为记录的计划。

## 简介
Swift的主要设计目标之一是允许在不牺牲抽象实现的加载时间情况下高效执行代码。

实现的抽象意味着，当底层实现更改为仍然满足原始接口的任何内容时，针对已发布接口正确编写的代码将正确运行。（实现的抽象就是，无论底层实现如何变动，已发布的的接口仍然正常可用。）这有非常多的潜在原因来证明需要提供这种抽象能力。苹果公司早期的期望是通过创建良好且安全的程序和库，使我们的内部和外部的开发人员很容易且过程不痛苦的改善苹果产品的生态系统，而细微的部署问题和/或对实现行为的不必要依赖可能会和我们的目标相违背。

几乎所有语言都提供了一定程度的实现抽象。比如，函数通常是不透明的数据类型，它们完全抽象出所执行操作的确切顺序。相同的，在c的结构体中添加新字段不会破坏应用其他字段的程序，这些程序可能需要重新编译，但是一旦编译通过，他们应该可以继续正常执行。（当然如果字段是通过索引而非名称访问的，可能不满足上述情况。）

## 组件化

程序和库不是作为最终用户独立汇编的大量源文件而分发的。相反，它们被打包成一个较大的组件，这些组件作为一个单元进行分发和加载。组成程序的每个组价都可能依赖于其他一些组件；他们的依赖关系图可以假定为是非循环的依赖关系。

由于组件是作为一个单元分布（在程序或库）中的，因此不需要组件内的ABI弹性。但它依然有可能有助于构建时的优化，但是由于语言的其他属性（模块系统、缺少预处理器、实例化模型等），swift的目标是提供比C/C++程序更好的构建时间。

组件可以广义地定义为整个操作系统，也可以狭义地定义为单个团队构建的产品。大型产品（如操作系统）的开发过程可能会阻碍模型的运行，即使只是修改了较低级别的组件，整个系统都需要重新编译，即使重新编译相对较快。Swift志在尽可能的减少不必要的抽象带来的弊端，同时也将允许任何符合无循环性规则的模型。

## 贯穿程序生命周期的抽象
大多数语言在程序的生命周期的不同阶段提供不同数量的抽象。这些阶段如下：

1. 编译：当前阶段，单个源文件会被转换成适合以后阶段使用的格式。仅在此阶段提供C/C++对象布局和C++虚拟表布局的抽象。将字段添加到结构体或将虚拟方法添加到类可能要求用户重新编译这些接口。
2. 绑定：当前阶段，编译后的源文件被合并到一个更大的组件里。这可能会发生在几个阶段里，比如：当目标文件连接到一个共享库，然后该共享库随后捆绑到OS的发行版本中。 non-fragile ABI中的OC类是通过在绑定期间发生的特殊处理进行布局的；就像做优化一样，运行时可以在执行时强制进行额外的布局更改，但是如果不正确，则此阶段将丢失抽象。
3. 安装：当前阶段，绑定好的组件被安置到系统并等待执行。如果代码的实现始终是在接口之前安装，那么这通常是一个失去抽象的好阶段。这是终端用户可以观察性能的第一阶段，除非安装时间长的离谱，否则在这里进行额外的处理几乎没有害处。
4. 加载：当前阶段，组件被载入内存并准备执行。OC在此阶段进行类布局，当加载完成，不能对类布局进行进一步的更改。程序加载期间，Java还会执行类文件的布局和附加验证。这个阶段执行的处理会延迟程序（或插件或其他组件）的启动。
5. 执行：当前阶段，代码段会被执行。在这种“阶段”之前，OC保证在当前阶段进行方法查找，这意味着始终可以向类动态添加方法。 允许代码动态重载的语言也必须在执行过程中强制执行抽象，尽管JIT技术可以减轻一些此类开销。 在此阶段执行的处理会直接降低操作速度。

## 表现力

某些语言的能力是会受到选择分解抽象的时机影响。

- 如果语言运行时提供了动态探索的函数，并通过反射使用组件中的语言结构，那么在执行时间之前，必须保留一些元数据。例如，调用一个函数需要有关它所使用的类型的签名和 ABI 信息，充分保留这些信息，以便调用代码对其重新组装。
- 如果语言运行时提供了动态更改或扩展组件中语言结构的功能，则必须保留与这些结构关联的完整抽象，直到执行时为止。例如，如果可以在运行时替换现有的“ virtual”方法，那么在编译时就不允许进行非虚拟化，而且必须至少有某种方法将该方法映射到所有派生类中的 vtable 偏移量; 如果可以动态添加这样的方法，则必须有某种方法可以使方法分派到字典上的能力。
- 对于可以动态加载或卸载的组件中的类扩展，上述情况同样适用

## 性能
抽象的性能成本主要有三种形式:
- 许多小的间接费用的直接成本
- 代码大小的膨胀归因于实现这些操作的额外逻辑
- 减少潜在的更强大的优化，如内敛和代码移动
正如前面提到的，我们可以在组件中避免这些开销，因为类不能再组件中扩展。
我们希望尽可能利用程序的部署属性来避免这些成本。

## 设计摘要
我们目前在 Swift 中的设计是为所有语言特性提供选择退出加载时的实现抽象（opt-out load-time abstraction of implementation）。仅此一点，就会招致不可接受的成本，或迫使广泛选择抽象。我们打算主要通过设计语言及其实现来减少不必要和无意的抽象:
- 在定义语言结构的组件中，其实现的所有细节都是可用的
- 当语言结构不在其定义组件之外公开时，它们的实现就不会受到限制
- 默认情况下，语言结构不会在其定义组件之外公开。这是独立地希望减少意外的 API surface area，但恰好也与性能设计良好地交互
- 避免不必要的语言保证，并利用这种灵活性来限制加载时间成本

我们还打算提供工具来检测接口中无意的更改。

## 组件
（这只是一个草图，值得拥有自己的设计文档。）

Swift将有一个集成的构建系统。这有以下几个目的：
- 它为项目创建了一个“单一事实来源”（single source of truth）,可以在工具之间共享
- 它通过限制文件之间的冗余计算来加速编译
- 它向编译器提供关于组件之间边界的信息

在复杂的情况下，需要描述构建过程。复杂的情况包括:
- 复杂的组件层次结构(见下文)
- 非 swift 源文件的存在(直接支持: . s，. c，. o，也可能是. m，. mm，. cpp)
- 除了可执行文件以外的构建产品(直接支持: executable、 . dylib (. framework?)、 . o，可能还有一些二进制组件分发)
- 库需求
- 部署需求
- 比-On更复杂的编译选项

这个规范文件将基本上作为 Swift 的驱动程序接口，可能需要如下类似的功能，例如 QA 覆盖，源自B&I 的继承设置。可能还需要某种基于目标的编程。

组件可能被分解成子组件的层次结构。组件图必须仍然是无环的。

每个组件都有一个弹性域，一个组件(本身或其组件层次结构中的祖先) ，其外部需要弹性。默认情况下，这是其层次结构中的顶级组件。

访问
（素描）
许多代码并不打算在它所出现的组件之外使用。下面是四个级别的访问控制，以及它们建议的拼写:
- [ api ]可从其他组件访问
- [ public ]只能从这个组件访问(可能需要更高级别的控制来处理non-trivial的组件层次结构，例如 public (部分组件))
- [ private ]只能从这个源文件访问
- [ local ]只能从包含声明中以词汇方式包含的事物中访问(可能没有用)

默认情况下，语言结构的可访问性是从其词汇上下文继承的。

全局上下文(即默认的可访问性)是[public] ，即可以从这个组件访问，但不能在它之外访问。

一个语言结构如果可以在它所出现的组件之外访问，就称为导出。

## 弹性
通常，弹性是一种可以更改语言结构实现的能力，而且不需要对使用该结构的代码进行进一步预加载时的处理，而且弹性域不包括定义该结构的组件。

弹性不允许改变语言结构的接口。这一个相当模糊的标准（下面会进行详细说明），但一般而言，接口变动会导致使用该结构的现有代码不能编译或使用不同的正式类型进行编译。

语言结构可能会选择不具有弹性的属性：[fragile]。部署版本可能与该属性相关联，如下所示: [ fragile (macosx10.7，ios5)]。删除[fragile]属性是接口更改，无论是否是版本控制的。为非版本控制添加[fragile]的属性是一种接口更改。为一个版本控制添加[fragile]属性并不是一个接口更改。还有一个[resilient]属性，专属于任何非[fragile]形式 ，可以明确地将声明描述为弹性的。

弹性在词汇上是继承的。它没有词汇上的限制，弹性语言结构可能有脆弱的子结构，反之亦然。全局上下文是有弹性的，尽管由于它也是[ public ](而不是[ api ]) ，对象实际上并不受弹性的限制。

我们打算提供一个自动检测接口变化的工具。

## 类型的属性

部署是一个抽象的平台名称和版本。
存在部署中的类型如果存在以下情况：
- 是一个内建类型，或
- 它是一个函数类型，其参数和结果类型存在于部署中，或
- 它是一个元祖类型，其所有组件类型都存在于部署中，或
- 它是一个结构体，枚举类型，并且他没有 [available]属性，以及用于匹配平台名称的更高版本。

对于导出的类型添加一个 [available]属性是接口变化的。

如果类型具有脆弱的表示形式（定义如下），则为空，并且：
- 它是一个元祖类型，没有非空组件类型，或
- 它是没有非空字段的结构体类型，或
- 它是一中枚举类型，带有一个替代类型，该替代类型不携带数据或携带空类型的数据

类型具有fragile表示，如果存在以下情况：
- 这是一个内建类型。表示形式应该从类型上显而易见。
- 这是一种功能类型。这个表示是一对指针: 一个有效的函数指针指针，和一个可能为空的可恢复指针。有关更多信息，请参见对话一节
- 它是一个元组类型，只有零散表示的组件类型。元组的表示使用 Swift 结构布局算法。即使元组没有fragile的表示，这也是正确的
- 它是一个类类型(也就是引用结构类型)。该表示形式是有效的可保留指针。
- 它是一个fragile的结构类型，没有弹性字段，也没有类型被fragile标识的字段。该表示使用 Swift 结构布局算法

如果不存在改类型的平台部署，且该类型具有非脆弱的表现，那该类型具有普遍脆弱的表现。一个定理是，所以组件全都满足类型具有通用脆弱的表现，如果是，类型大小，未填充大小和对齐方式是？（固定的）。

Swift的结构布局算法将字段列表作为输入，并执行以下操作：
1. 字段排名：
  - 普遍脆弱字段排名较高
  - 如果两个字段A和B都是普遍脆肉的类型
  - 如果没有其他条件适用，则在原始序列中较早出现的字段将具有较高的排名。
2. 结构的最初大小为0.
  - 表现形式和A的类型比B的类型更对齐, 否则，如果A的原始顺序出现在B之前
3. 另外，A字段排名比B高，如果
  - A具有普遍最弱的表现并且B没有，或

Swift提供如下类型：
语言结构可能具有弹性，但仍然可以定义或具有某种类型
下面的讨论中，区分具有已知表示形式的类型和不具有已知表示形式的类型是很重要的。

Swift提供
对于某些结构体，重要的是知道该结构体从未进行弹性部署，因此通常将其视为接口更改已更改接口
弹性几乎影响每种语言功能。

执行时抽象并非没有成本，我们并不希望在不必要的情况下产生这些成本。除了作为构建时的优化之外，不需要许多形式的执行时抽象，因为在实践中该软件以大组块部署，并且可以同时进行编译。在这样的弹性单元，许多执行时抽象可以被分解。但是，这意味着语言结构的抽象是依赖上下文：可能需要以一种弹性的方式从另外一个弹性单元访问它，但是可以从一个弹性单元更有效地访问它。一个重要的例外是无法在其弹性单位外部访问的结构。如果某个结构体可以在其弹性单元之外的某些理论环境中访问，则可以说该结构可以导出。

如果仅依靠结构访问结构，则该结构具有弹性。

如果结构在所以可以访问的上下文中都是非弹性的，则该结构通常被称为非弹性的。

许多API愿意选择性地“锁定”其某些组件结构，这通常是因为结构的形式是固有的（例如，点是一对双精度值），或者对于性能值得重视的重要程度（例如，基本数据结构的访问者）。这需要[unchanging]批注，等效于说该结构普遍是非弹性的。

Swift中的大多数语言结构都具有弹性。随着语言结构的发展和增强，该文档将需要更新。 

## 类型类别

出于本文档的目的，Swift中有五种类型。
- 原始类型：i1, float32 等。由现实定义的名义类型。
- 函数：（）-> int,(NSRect，bool)-> (int，int)等。结构类型。
- 元祖: (NSRect, bool), (int, int), 等. 结构性产品类型。
- 命名值类型： int, NSRect, 等，由多种语言结构创建的标称类型。
- Named reference types：MyBinaryTree, NSWindow, 等。由多种语言结构创建的标称类型。

原始类型普遍是非弹性的。
函数类型普遍是非弹性的（请参阅通话部份）。
函数类型普遍是非弹性的当且仅在他们的组件类型是非弹性的情况下。
函数内的命名类型普遍是非弹性的。
带有 [unchanging] 声明的命名类型普遍是非弹性的。问题，因为需要/渴望使事情取决于类型是否普遍是非弹性。使得在不破坏ABI的情况下无法添加[unchanging]。请参阅通话部份。
所有其他命名类型仅在与其声明文件位于同一弹性单元中的上下文中是非弹性的。

## 存储

基元类型使用具有基元的大小和对齐方式。

命名引用类型始终具有单个指针的大小和对齐方式。

函数类型始终具有两个指针的大小和对齐方式，第一个是最大非弹性函数指针（请参与调用部分），第二个是retain/released指针。

如果一个元祖类型不是普遍非弹性的，它的元素布局会按照C结构布局规则顺序进行存储。布局必须在运行时计算。单独存储并不是一个切实可行的选择。

## 命名类型

将[unchanging]注释放在任何这些类型上都是错误的：
- 具有非普遍无弹性的成员类型的结构类型
- 枚举器的枚举类型，其类型不是普遍非弹性的
- 类的扩展
- 一个类，其主定义包含的字段不是普遍非弹性的

## 类

将[unchanging]注释放在类扩展上是错误的。
将[unchanging]注释放在一个类上是错误的，该类的主定义包含一个字段，该字段的类型在可以访问该类的上下文中具有潜在的弹性。也就是说，如果类被导出，那么它的所有领域都必须是普遍的非弹性的。如果它不被出口，它的所有领域必须在它的弹性单元内是非弹性的。
允许在类扩展中向[unchanging]类中添加字段。这样的字段总是侧面存储的，即使它们声明在同一个弹性单元中。

## 对象

目前，Swift里面的类型均为“first-class”，这意味着可以进行范围广泛的泛型操作。
1. 一级对象的大小和布局
  1. 局部变量
  2. 全局变量
  3. 动态分配的对象
  4. 结构的成员子对象
  5. 类的基础子对象
  6. 数组的元祖子对象
  7. 函数的参数
  8. 函数返回值
2. 对象上的操作集
  1. 所有协议
  2. 对于特定的协议（？）
3. 对象上的操作集
  1. ...


ABI弹性意味着对语言实体不做任何假设，这限制了这些实体的维护者以后更改它们的能力。语言实体是函数和对象。ABI的弹性能力是Swift的首要任务。
- 函数
- 对象及其类型
我们会聊下以上话题

## 会议笔记

我们确信希望支持弹性值类型。用例有：strings， dates，opaque numbers， 等。希望哪怕没有具体实现的情况下锁定API。

这意味着我们必须支持运行时数据布局。需要这样的例子。

我们需要更加弹性的代码而不是添加 [unchanging]标识。有两个层次：[born_unchanging] 针对那些通用非弹性，[unchanging] 针对那些曾经是弹性的。提议的两个名称： [born_fragile] 和 [fragile]。

全局函数总是导出一个具有最大弹性的入口点。如果存在任何[fragile]参数，和并不存在任何弹性参数，他们也会导出一个[fragile]的拷贝。调用者会做什么？我想我们得知道他们在部署什么。

需要为[ref]参数提供一些具体的表示。

## Notes from whiteboard conversation with Doug. 与道格的白板谈话记录

脆弱性对各类对象意味着什么呢？
结构体(值类型)：布局是固定的
内部字段：直接获取内部字段而非通过getter/setter
内部方法：像任何函数一样
类（引用类型）：结构组件的布局是固定的
内部字段：直接获取对比getter/setter
内部方法：像任何函数一样
类扩展：类似于类。如何处理多个类扩展的布局？微不足道的
函数：无形的
全局变量：可以直接访问。类型如果是born_fragile：值是全局地址。类型是弹性的：左值加载的是全局指针。类型是fragile：值加载的是全局指针，也是可选的全局指针，其使用与具有脆弱参数类型的全局函数相同的机制。
协议：born_fragile => 以vtable的方式布局。他们可以用有弹性吗？
他们的实现：vtable的实现细节是已知的。
枚举：布局，变量集合

## Notes from second meeting 第二次会议记录

适应性属性：
- born_fragile，fragile，resilient
- 想要调用born_fragile=>fragile，fragile=>fragile（macosx10.42）
- 除了“default”，越小的东西越有侵略性。更重要的是要有有个ABI检查工具
- 使用可用属性方案：platformX.Y.Z

组件：非常适合构建系统
用户有个有能力写swift [foo.swift]+，并且将其编译成可执行的文件

对于任何复杂的组件，需要一个组件描述文件。
- 组件层次
- 构建产物类型：可执行文件，dylib， 甚至是对象文件
- 非swift资源（对象文件，c文件等等）
- 部署选项（部署在 macosxX.Y.Z）
- 需要一系列“包含某某子组件”的描述
- 可能需要一定程度的元编程，可能是预处理器

自动查找组件描述文件的方法:命名一个目录（用固定的名称查找），不命名（在当前目录中查找）

组件组织是我们能否访问脆弱的弹性决策的决策算法。
- 不一定只是“你是我的一部分”吗？ 也许“你在我的域/组件树/其他范围内”

韧性是词汇遗传的。
- 脆弱枚举中的声明是隐式脆弱的，等。
- Except anything inside a function is fragile.

按声明类型分解、
- typealias没有弹性
- 结构体--字段的设置/顺序可以更改--意味着大小/对齐方式，布局，复制/销毁语义 等，都能该白
- 字段 - 直接访问 VS getter/setter
- 函数 - 最高级别
- 类型 - 最高级别
- 类 - 类似于结构体，另外:
- 基础类 -- 不能完全移除一个基础类 (breaks interface)，但是可以引入新的中间base（类？）
- 虚拟分发 --table 对比dictionary，虚拟化 (to which decl?)。一些表可以使用静态偏移量和动态偏移量进行查找。
- 函数 -- inlineability
- 变量 -- 直接访问VSgetter/setter。对本质上不脆弱的类型的直接访问是要间接的，因为他们可能会异步分配空间。通常，可能是“actor-loacl”，对于模型来说就是“全局变量”。
- 类的扩展 -- 与类类似。
- 协议 -- 不能移除/修改存在的方法，但可以增加默认方法。弹性地执行此操作需要检查加载时间。vtable 用于非默认方法，？其他？
- 枚举 - 一组直接代表的案例
- 枚举元素 - 直接代表 vs 注入/投射
- 枚举 - 调用它，以便我们可以拥有一个可扩展的东西，它不承诺任何数据字段。弹性时始终为i32。
- 常量 - 默认是fragile，就像var一样